# Напишите программу, которой на вход подается последовательность чисел через пробел,
# а также запрашивается у пользователя любое число.

# В качестве задания повышенного уровня сложности можете выполнить проверку соответствия указанному в условии
# ввода данных.

# Далее программа работает по следующему алгоритму:
# Преобразование введённой последовательности в список
# Сортировка списка по возрастанию элементов в нем (для реализации сортировки определите функцию)
# Устанавливается номер позиции элемента, который меньше введенного пользователем числа, а следующий за ним больше
# или равен этому числу.

# При установке позиции элемента воспользуйтесь алгоритмом двоичного поиска, который был рассмотрен в этом модуле.
# Реализуйте его также отдельной функцией.
#
# Помните, что у вас есть числа, которые могут не соответствовать заданному условию. В этом случае необходимо вывести
# соответствующее сообщение

data=(input("Введите целые числа через пробел, и нажмите ввод :"))
print("Проверка ввода...")

if "." in data or "," in data:
    raise ValueError("Вы ввели не целое число")
print(data)
data= data.split()
data = [int(i) for i in data]
print(data)

element=int(input("Введите целое числа и нажмите ввод :"))
if element in data:
    i=data.index(element)
    print ("Введённое число есть в списке введённых раньше, \n сейчас цифра",element,
           "находится в неотсортированном списке под индексом",i)
else: data.append(element)

for i in range(len(data)):  # перестановкой
    for j in range(len(data) - 1):
        if data[j] > data[j + 1]:
            data.append(data[j])
            data.pop(j)
print("Отсортированный список",data)

if element > max(data) or element < min(data) :
     exit("Введено значение выходящее за рамки введённых цифр")

def binary_search(data, element, left, right): #честно скопированный с лекции :)
    if left > right:  # если левая граница превысила правую,
        return False  # значит элемент отсутствует
    middle = (right + left) // 2  # находимо середину
    if data[middle] == element:  # если элемент в середине,
        return middle  # возвращаем этот индекс
    elif element < data[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(data, element, left, middle - 1)
    else:  # иначе в правой
        return binary_search(data, element, middle + 1, right)
pozition =binary_search(data, element, 0, len(data)-1)
print("Индекс искомого числа",pozition)

if pozition == 0:
    print("Введённое число находится первым в списке, ПОЗИЦИЯ следующий за ним больше или равен этому числу:", pozition+1)
elif pozition == len(data) - 1:
    print("Введённое число находится последним в списке, номер ПОЗИЦИИ элемента, который меньше введенного:", pozition-1)
else: print("Номер ПОЗИЦИИ элемента, который меньше введенного:", pozition-1,
            "\n ПОЗИЦИЯ следующий за ним больше или равен этому числу:", pozition+1)
#ВАЖНО: требуется установить именно номера позиций числа больше и меньше введённого числа,
# так же не указано должно ли быть искомое число в списке